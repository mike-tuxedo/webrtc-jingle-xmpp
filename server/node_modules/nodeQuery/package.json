{
  "name": "nodeQuery",
  "description": "DOM manipulation from the server.",
  "author": {
    "name": "Thomas Blobaum"
  },
  "version": "0.0.9-1",
  "main": "index.js",
  "keywords": [
    "DOM",
    "manipulation",
    "jquery",
    "zepto",
    "dnode",
    "socket.io",
    "RPC",
    "browserify"
  ],
  "dependencies": {
    "browserify": "x",
    "underscore": "x",
    "dnode": "x",
    "uglify-js": "x"
  },
  "repository": {
    "type": "git",
    "url": "https://tblobaum@github.com/tblobaum/nodeQuery.git"
  },
  "engines": {
    "node": ">=0.4.10"
  },
  "subdomain": "todos",
  "scripts": {
    "start": "examples/todos.js"
  },
  "readme": "nQuery (beta)\n=============\n\nnQuery lets you use $() on the server to manipulate the browser side in realtime. It accomplishes \nthis using Socket.io, Dnode, Browserify, and either jquery or Zepto.\n\nnQuery is a minimalist DOM manipulation framework, it's fast, and its bringing all of the \njquery methods to the server so you dont have to write (or serve!) any client side javascript in order to make a realtime browser application.\n\nThe current API matches both jquery and zepto counterparts, so you can include either one on the client side.\n\nThe goal is to have a full DOM manipulation framework that works in realtime from the server side.  This means you are mostly just setting attributes, html, values and binding events in jquery just like you would normally, but these methods work seamlessly with the server side of your code.\n\n\nInstall\n-------\n\n    $ npm install nodeQuery\n\nUsage\n-----\nCreate a file to serve up jquery and nquery and put it in /public\n\n```html\n<!doctype html>\n<html>\n<body>\n<script type='text/javascript' src='/jquery.js' charset='utf-8'></script> \n<script type='text/javascript' src='/nquery.js' charset='utf-8'></script>\n</body>\n</html>\n````\n\nCreate an app.js file\n\n```javascript\n\nvar Express = require('express')\n    , dnode = require('dnode')()\n    , nQuery = require('../')\n    , express = Express.createServer();\n    \nvar app = function ($) {\n    $.on('ready', function () {\n        $('body').append('Hello World');\n    });\n};\n\nnQuery\n  .use(app);\n\nexpress\n  .use(nQuery.middleware)\n  .use(Express.static(__dirname + '/public'))\n  .listen(3000);\n\ndnode\n  .use(nQuery.middleware)\n  .listen(express);\n\n\n````\n\nVisit the html file you created to see \"Hello World\"\n\n\nNotes\n-----\nRemember that just because you can write jquery on the serer doesnt mean you will always want to.  A click event being bound to the server for a form is amazingly powerful, but if your mouseover or swipe event only changes the display features of your app (i.e. color, size) then it most likely still belongs on the client to reduce the server load.  There is a method in nQuery.js similar to $(document).ready() for the client as well as the server.  On the client it is nQuery.ready()\n\n```html\n<!doctype html>\n<html>\n<body>\n<script type='text/javascript' src='/jquery.js' charset='utf-8'></script> \n<script type='text/javascript' src='/nquery.js' charset='utf-8'></script>\n<script type='text/javascript'>\nnQuery.ready(function(options) {\n    // optionally get something from the server with ready(options)\n    // do something once the server has fired \"ready()\"\n    // ...\n});\n</script>\n</body>\n</html>\n````\n\nMethods\n-------\n\nSo far only a limited number of jquery/zepto methods are available, but these include some \nof the most powerful functionality in jquery.  You may create live bindings to events and you\ncan use all of the event types that are available with jquery or zepto to do this, including:\n\n    swipe swipeLeft swipeRight swipeUp swipeDown doubleTap tap longTap focusin focusout load     resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout change     select keydown keypress keyup error\n\nSample usage of methods on the server:\n\n```javascript\n\nnQuery.use(function ($, connection) {\n  // similar to '$(document).ready()', this function\n  // is called after the client DOM is ready, a callback is passed\n  // aswell, which calls 'nQuery.ready()' on the browser\n  $.on('ready', function (callback) { \n    \n    $('.container').append('<a href=\"#/click\" class=\"clickable\">Click me, Im a binding.</a>');\n    \n    $('.clickable').live('click', function () {\n        $('.clickable').html('You clicked it!');\n        $('.clickable').attr('href', console.log);\n    });\n\n    $('.container').append('<span class=\"hoverable\">Hover me.</span>');\n    \n    $('.hoverable').live('mouseover', function () {\n        $('.hoverable').html('hover event');\n    });\n    \n    // bind an event to an element and any future elements that match the selector\n    $('.title').live('swipe', function () {\n        $('.title').html('swipe event');\n    });\n    \n    // bind an event to an element which already exists in the dom\n    $('.hoverable').bind('mouseout', function () {\n        $('.hoverable').html('Im back again!');\n    });\n    \n    // unbind an event\n    $('.hoverable').unbind('mouseout', function () {\n        $('.hoverable').html('Im back again!');\n    });\n\n    // get the name of the selector (useful to determine if html element exists)\n    $('body').get(console.log);\n    \n    // get the number of elements\n    $('body').size(console.log);\n    \n    // get the index of the element\n    $('body').index(console.log);\n    \n    $('body').height(console.log);\n    \n    $('body').width(console.log);\n\n    // set the html contents of the element(s)\n    $('body').html('<div class=\"app\"></div>');\n    \n    // set the text contents of the element(s)\n    $('.app').text('Hello World');\n    \n    // add html (or a DOM Element) after the element\n    $('.app').after('->>');\n    \n    // add html (or a DOM Element) before the element\n    $('.app').before('<<-');\n    \n    // add html (or a DOM Element) at the beginning of the element contents\n    $('.container').prepend('Clock:');\n    \n    // add html (or a DOM Element) at the end of the element contents\n    $('.container').append('is the current time');\n    \n    // reverse of append\n    $('.container').appendTo('.app');\n    \n    // reverse prepend\n    $('.container').prependTo('.app');\n    \n    // replace element with html\n    $('.foo').replaceWith('<div></div>');\n    \n    // forces elements to be hidden\n    $('.clock').hide();\n    \n    // forces elements to be displayed\n    $('.clock').show();\n     \n    // set a CSS property\n    $('.clock').css('background-color', '#eee');\n    \n    // set an attribute\n    $('.clock').attr('background-color', '#eee');\n    \n    // get an attribute\n    $('.clock').attr(console.log);\n    \n    // serialize a form or list of elements\n    $('.form').serialize(console.log);\n    \n    // call \"nQuery.ready()\" on the browser\n    callback();\n    \n  });\n\n});\n\n\n````\n\nMore Examples:\n---------\nCheck out the todos app written with [tubes](https://github.com/tblobaum/tubes) and nquery\n\nCheck out the examples folder for a few very simple demos. There are two different clocks \nthat run based on the server time, a twitter search app that implements \nbackbone conventions and a simple hello world app.\n\nMIT License\n\n",
  "readmeFilename": "README.markdown",
  "_id": "nodeQuery@0.0.9-1",
  "dist": {
    "shasum": "2256816628ae2739309a5dc87c36f8762c73975b"
  },
  "_from": "nodeQuery"
}
